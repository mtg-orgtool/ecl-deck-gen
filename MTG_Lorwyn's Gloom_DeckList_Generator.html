<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MTG Decklist Image Generator v3 - Avatar TLA</title>
<style>
    :root {
        --bg-color: #2c2c2c;
        --panel-color: #3e3e3e;
        --text-color: #e0e0e0;
        --accent-color: #da7a5a;
        --success-color: #9BD3AE;
    }
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        margin: 0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    h1 { margin-bottom: 20px; font-size: 1.5rem; }
    
    .container {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        width: 100%;
        max-width: 1200px;
    }

    .input-panel {
        flex: 1;
        min-width: 340px;
        background: var(--panel-color);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .output-panel {
        flex: 2;
        min-width: 320px;
        background: #1a1a1a;
        padding: 20px;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        overflow: auto;
        min-height: 500px;
    }

    .section-title {
        font-weight: bold;
        font-size: 1rem;
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        gap: 8px;
        border-bottom: 1px solid #555;
        padding-bottom: 5px;
    }
    
    .badge-req { color: #ff6b6b; font-size: 0.8rem; border: 1px solid #ff6b6b; padding: 1px 4px; border-radius: 4px; }
    .badge-opt { color: #88cf88; font-size: 0.8rem; border: 1px solid #88cf88; padding: 1px 4px; border-radius: 4px; }

    textarea {
        width: 100%;
        height: 120px;
        background: #222;
        color: #fff;
        border: 1px solid #555;
        border-radius: 4px;
        padding: 8px;
        font-family: monospace;
        resize: vertical;
    }
    
    .file-drop-zone {
        border: 2px dashed #666;
        padding: 15px;
        text-align: center;
        border-radius: 6px;
        background: #333;
        transition: 0.2s;
        cursor: pointer;
        position: relative;
    }
    .file-drop-zone:hover { border-color: #aaa; background: #383838; }
    .file-drop-zone.loaded { border-color: var(--success-color); background: #2f3a33; }
    
    input[type="file"] {
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        opacity: 0;
        cursor: pointer;
    }

    button#generate-btn {
        /* background: var(--accent-color); */
        color: white;
        border: none;
        padding: 0;
        border-radius: 50%;
        width: 80px;
        height: 80px;
        cursor: pointer;
        align-self: center;
        box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        transition: transform 0.1s;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-top: 10px;
    }
    button#generate-btn:hover { transform: scale(1.05); }
    button#generate-btn:active { transform: scale(0.95); }

    button#generate-btn img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 50%;
    }

    canvas {
        max-width: 100%;
        height: auto;
        box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }

    button#saveBtn {
        background-color: #555;
        color: #ccc;
        border: none;
        padding: 12px 20px;
        border-radius: 6px;
        font-size: 1rem;
        font-weight: bold;
        cursor: pointer;
        margin-top: 20px;
        transition: background-color 0.2s;
    }
    button#saveBtn:not(:disabled) { background-color: var(--accent-color); color: white; }
    button#saveBtn:disabled { cursor: not-allowed; opacity: 0.5; }
    
    .status-text { font-size: 0.85rem; color: #aaa; margin-top: 5px; min-height: 1.2em;}
    .success-text { color: var(--success-color); font-weight: bold; }

</style>
</head>
<body>

    <h1>MTG Decklist Generator v3</h1>

    <div class="container">
        <!-- Input Area -->
        <div class="input-panel">
            
            <!-- 1. DB File -->
            <div>
                <div class="section-title">1. カードリストデータ <span class="badge-req">必須</span></div>
                <div class="file-drop-zone" id="zone-db">
                    <div id="text-db">mtg_TLA_list.txt を選択<br>(クリック または D&D)</div>
                    <input type="file" id="file-db" accept=".txt">
                </div>
                <div class="status-text" id="status-db"></div>
            </div>

            <!-- 2. Decklist -->
            <div>
                <div class="section-title">2. デッキリスト <span class="badge-req">必須</span></div>
                <textarea id="deck-input" placeholder="カード名　(コスト)　×1&#13;&#10;（Arenaのエクスポート形式など）"></textarea>
            </div>

            <!-- 3. Image Folder -->
            <div>
                <div class="section-title">3. カード画像フォルダ <span class="badge-opt">推奨</span></div>
                <div class="file-drop-zone" id="zone-img">
                    <div id="text-img">「cardlist」フォルダを選択<br>(クリックしてフォルダを選択)</div>
                    <input type="file" id="file-img" webkitdirectory directory multiple>
                </div>
                <div class="status-text" id="status-img">未選択（画像なしで生成します）</div>
            </div>

            <!-- 4. CSV -->
            <div>
                <div class="section-title">4. 17landsデータ <span class="badge-opt">任意</span></div>
                <div class="file-drop-zone" id="zone-csv">
                    <div id="text-csv">.csv ファイルを選択</div>
                    <input type="file" id="file-csv" accept=".csv">
                </div>
                <div class="status-text" id="status-csv"></div>
            </div>

            <button id="generate-btn" title="画像を生成">
                <img src="mm_wk19_299_t3.jpg" alt="画像を生成">
            </button>
        </div>

        <!-- Output Area -->
        <div class="output-panel">
            <canvas id="deck-canvas"></canvas>
            <button id="saveBtn" disabled>画像を保存</button>
            <div style="margin-top:15px; color:#888; font-size:0.9rem;">
                生成された画像は右クリックで「名前を付けて画像を保存」できます
            </div>
        </div>
    </div>

<script>
// --- Global State ---
let cardDatabase = {};
let nameMap = new Map(); // 【追加】日英対応マップ
let gihwrData = [];      // 【修正】初期値を空配列に
let localImageFiles = {};

// --- File Handling Helper ---
function setupFileInput(id, zoneId, textId, statusId, callback) {
    document.getElementById(id).addEventListener('change', function(e) {
        const files = e.target.files;
        if (!files.length) return;
        
        callback(files, (msg, success) => {
            const el = document.getElementById(statusId);
            el.innerText = msg;
            if (success) {
                el.classList.add('success-text');
                document.getElementById(zoneId).classList.add('loaded');
                document.getElementById(textId).innerText = files.length === 1 ? files[0].name : `${files.length} ファイル`;
            }
        });
    });
}

// 1. DB File
setupFileInput('file-db', 'zone-db', 'text-db', 'status-db', (files, report) => {
    const reader = new FileReader();
    reader.onload = e => {
        cardDatabase = parseCardDatabase(e.target.result);
        report(`読込完了: ${Object.keys(cardDatabase).length} 枚のカードデータを認識`, true);
    };
    reader.readAsText(files[0]);
});

// 3. Image Folder
setupFileInput('file-img', 'zone-img', 'text-img', 'status-img', (files, report) => {
    localImageFiles = {};
    let count = 0;
    for (let f of files) {
        if (f.type.startsWith('image/')) {
            const namePart = f.name.substring(0, f.name.lastIndexOf('.')).toLowerCase();
            localImageFiles[namePart] = f;
            count++;
        }
    }
    report(`読込完了: ${count} 枚の画像ファイル`, true);
});

// 4. CSV File
setupFileInput('file-csv', 'zone-csv', 'text-csv', 'status-csv', (files, report) => {
    const reader = new FileReader();
    reader.onload = e => {
        parse17LandsCSV(e.target.result);
        report(`読込完了: ${Object.keys(gihwrData).length} 件の統計データ`, true);
    };
    reader.readAsText(files[0]);
});


// --- Parsers ---
function parseCardDatabase(text) {
    const db = {};
    nameMap = new Map(); // 【追加】マップを初期化
    const lines = text.split('\n');
    let currentCard = {};
    lines.forEach(line => {
        line = line.trim();
        if (!line) return;

        if (line.startsWith('英語名：')) {
            if (currentCard.nameJp || currentCard.nameEn) {
                if (currentCard.nameEn && currentCard.nameJp) nameMap.set(currentCard.nameEn, currentCard.nameJp);
                if (currentCard.nameJp) db[currentCard.nameJp] = { ...currentCard };
                if (currentCard.nameEn) db[currentCard.nameEn] = { ...currentCard };
            }
            currentCard = {};
            currentCard.nameEn = line.replace('英語名：', '').trim();
        } else if (line.startsWith('日本語名：')) {
            // 【修正】カッコ書き（読み仮名など）を削除して登録する
            let jpName = line.replace('日本語名：', '').trim();
            // 全角カッコ（）や半角カッコ()の中身ごと削除
            jpName = jpName.replace(/（.+）/, '').replace(/\(.+\)/, '').trim();
            currentCard.nameJp = jpName;
        } else if (line.startsWith('コスト：')) {
            currentCard.cost = line.replace('コスト：', '').trim();
        } else if (line.startsWith('タイプ：')) {
            currentCard.typeLine = line.replace('タイプ：', '').trim();
        } else if (line.startsWith('Ｐ／Ｔ：')) {
            currentCard.pt = line.replace('Ｐ／Ｔ：', '').trim();
        }
    });
    // 最後のカードを保存
    if (currentCard.nameJp || currentCard.nameEn) {
        if (currentCard.nameEn && currentCard.nameJp) nameMap.set(currentCard.nameEn, currentCard.nameJp);
        if (currentCard.nameJp) db[currentCard.nameJp] = { ...currentCard };
        if (currentCard.nameEn) db[currentCard.nameEn] = { ...currentCard };
    }
    return db;
}

function parse17LandsCSV(text) {
    gihwrData = [];
    const lines = text.split('\n');
    if (lines.length < 2) return;

    const headerLine = lines[0].trim();
    const headers = headerLine.split(',').map(h => h.trim().replace(/"/g, ''));
    const nameIdx = headers.indexOf('Name');
    const gihwrIdx = headers.indexOf('GIH WR');

    if (nameIdx === -1 || gihwrIdx === -1) {
        alert('CSVのヘッダーに "Name" または "GIH WR" が見つかりません。');
        return;
    }

    for (let i = 1; i < lines.length; i++) {
        const row = parseCSVLine(lines[i]);
        if (row.length > Math.max(nameIdx, gihwrIdx)) {
            const englishName = row[nameIdx].trim();
            const japaneseName = nameMap.get(englishName);
            let finalName = englishName;

            if (japaneseName) {
                finalName = `${japaneseName}/${englishName}`;
            } else {
                console.warn(`日英マップに '${englishName}' が見つかりませんでした。`);
            }
            gihwrData.push({
                'Name': finalName,
                'GIH WR': row[gihwrIdx].trim()
            });
        }
    }
    console.log("17landsデータをロードしました:", gihwrData); // 確認ログ
}
function parseCSVLine(text) {
    const res = []; let cell = ''; let q = false;
    for (let c of text) {
        if (c === '"') q = !q;
        else if (c === ',' && !q) { res.push(cell); cell = ''; }
        else cell += c;
    }
    res.push(cell); return res;
}

/**
 * 【修正】マナコスト文字列から点数で見たマナコスト(MV)を計算する（日本語対応版）
 * @param {string} costStr - "(2)(赤)" のようなコスト文字列
 * @returns {number} - 計算されたマナコスト
 */
// 1. 新・マナコスト計算関数
function getManaValue(costStr) {
    if (!costStr) return 0;
    let total = 0;
    
    // 数字のマナ: (2) や (２) を抽出
    const numMatch = costStr.match(/[\(（]([0-9０-９]+)[\)）]/g);
    if (numMatch) {
        numMatch.forEach(m => {
            // 括弧を除去して数値化
            let numStr = m.replace(/[\(（\)\）]/g, '');
            // 全角数字を半角に変換
            numStr = numStr.replace(/[０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
            const val = parseInt(numStr);
            if (!isNaN(val)) total += val;
        });
    }

    // 有色マナ・シンボル: (W), (U/B) などをカウント
    const symMatch = costStr.match(/[\(（]([a-zA-Z/]+)[\)）]/g);
    if (symMatch) {
        // X は0マナ扱いとして除外
        symMatch.forEach(m => {
            if (!m.toUpperCase().includes('X')) total += 1;
        });
    }
    
    return total;
}

// --- Deck Logic ---
function processDeck() {
    const rawList = document.getElementById('deck-input').value;
    const lines = rawList.split('\n');
    const deckCards = [];
    const basicLands = ['Plains', 'Island', 'Swamp', 'Mountain', 'Forest', '平地', '島', '沼', '山', '森'];

    lines.forEach(line => {
        line = line.trim();
        if (!line) return;

        // 【要件1】'??' を含む行は無視する
        if (line.includes('??')) {
            return;
        }

        let count = 1;
        let namePart = line;
        const countMatch = line.match(/[x×](\d+)$/);
        if (countMatch) {
            count = parseInt(countMatch[1]);
            namePart = line.substring(0, countMatch.index).trim();
        }

        let dbKey = namePart;
        if (namePart.includes('/')) {
            const parts = namePart.split('/');
            if (cardDatabase[parts[0].trim()]) dbKey = parts[0].trim();
            else dbKey = parts[1].trim();
        }
        dbKey = dbKey.replace(/\(.*\)$/, '').trim();

        let info = cardDatabase[dbKey];
        const isBasicLand = basicLands.some(l => namePart.includes(l));

        // 【要件2】マスターデータに存在しないカードは無視する (基本土地を除く)
        if (!info && !isBasicLand) {
            console.warn(`カードが見つかりません: ${namePart}`);
            return;
        }

        let type = 'Other', cost = '', color = 'C', pt = '', nameEn = dbKey, nameJp = dbKey;

        if (info) {
            cost = info.cost || ''; type = info.typeLine || 'Other'; pt = info.pt || '';
            nameEn = info.nameEn || dbKey; nameJp = info.nameJp || dbKey;
            // 色識別のための簡易パーサー
            color = parseColor(cost).color;
        } else if (isBasicLand) {
            type = 'Land'; color = 'L';
        }

        let catOrder = 99;
        if (type.match(/クリーチャー|Creature/)) catOrder = 0;
        else if (type.match(/アーティファクト|Artifact/)) catOrder = 1;
        else if (type.match(/インスタント|Instant/)) catOrder = 2;
        else if (type.match(/ソーサリー|Sorcery/)) catOrder = 3;
        else if (type.match(/エンチャント|Enchantment/)) catOrder = 4;
        else if (type.match(/土地|Land/)) catOrder = 5;

        // 【要件3 修正】グローバル変数 gihwrData (配列) を使って検索
        let gihwr = 0;
        if (gihwrData.length > 0) {
            const ratingData = gihwrData.find(r => r.Name.endsWith(nameEn));
            if (ratingData) {
                gihwr = ratingData['GIH WR'];
                // console.log(`Tierデータあり: ${nameJp || nameEn} -> ${gihwr}`);
            }
        }

        // 【最重要】新しいマナコスト計算関数でcmcを算出
        const cmc = getManaValue(cost);

        deckCards.push({
            displayName: namePart, nameEn, nameJp, count, cmc, cost, color, type, pt, catOrder, gihwr
        });
    });

    // 【修正】カードをマナコスト別にグルーピングする
    const groupedCards = {
        cost0: [], cost1: [], cost2: [], cost3: [], cost4: [], cost5: [], cost6plus: [], lands: []
    };

    deckCards.forEach(card => {
        if (card.type.includes('Land') || card.type.includes('土地')) {
            groupedCards.lands.push(card);
        } else {
            switch (card.cmc) {
                case 0: groupedCards.cost0.push(card); break;
                case 1: groupedCards.cost1.push(card); break;
                case 2: groupedCards.cost2.push(card); break;
                case 3: groupedCards.cost3.push(card); break;
                case 4: groupedCards.cost4.push(card); break;
                case 5: groupedCards.cost5.push(card); break;
                default: groupedCards.cost6plus.push(card); break;
            }
        }
    });

    // 各グループ内でソートする
    const sortInGroup = (a, b) => {
        // 【修正】Tierランクを最優先でソート
        const tierScoreA = getTierScore(a.gihwr);
        const tierScoreB = getTierScore(b.gihwr);
        if (tierScoreA !== tierScoreB) {
            return tierScoreB - tierScoreA; // Tierランクを降順でソート
        }
        // Tierが同じ場合はカードタイプ順
        return a.catOrder - b.catOrder;
    };

    for (const key in groupedCards) {
        groupedCards[key].sort(sortInGroup);
    }
    // 【修正】土地のソート順を変更
    groupedCards.lands.sort((a, b) => {
        // 1. Tierランクを最優先でソート
        const tierScoreA = getTierScore(a.gihwr);
        const tierScoreB = getTierScore(b.gihwr);
        if (tierScoreA !== tierScoreB) {
            return tierScoreB - tierScoreA; // Tierランクを降順でソート
        }
        // 2. Tierがない、または同じ場合は枚数順でソート
        if (a.count !== b.count) {
            return b.count - a.count; // 枚数を降順でソート
        }
        // 3. 枚数も同じ場合は名前順
        return a.displayName.localeCompare(b.displayName);
    });

    return groupedCards;
}

/**
 * 1. GIH WRの数値からTier文字列を返す
 * @param {string | number} gihwrValue - "64.0%" や 55.0 のような勝率データ
 * @returns {string} - "A+", "B-", "U" などのTier文字列
 */
function getTier(gihwrValue) {
    if (!gihwrValue || String(gihwrValue).trim() === '-' || String(gihwrValue).trim() === '') return 'U';
    const value = parseFloat(String(gihwrValue).replace('%', ''));
    if (isNaN(value)) return 'U';

    if (value >= 64.0) return 'A+';
    if (value >= 62.5) return 'A';
    if (value >= 61.5) return 'A-';
    if (value >= 60.0) return 'B+';
    if (value >= 58.8) return 'B';
    if (value >= 57.5) return 'B-';
    if (value >= 56.2) return 'C+';
    if (value >= 55.0) return 'C';
    if (value >= 53.7) return 'C-';
    if (value >= 52.5) return 'D+';
    if (value >= 51.2) return 'D';
    if (value >= 50.0) return 'D-';
    return 'F';
}

const tierOrder = {
    'A+': 13, 'A': 12, 'A-': 11,
    'B+': 10, 'B': 9,  'B-': 8,
    'C+': 7,  'C': 6,  'C-': 5,
    'D+': 4,  'D': 3,  'D-': 2,
    'F':  1,  'U': 0
};

/**
 * GIH WRからTierのソート用スコアを取得する
 * @param {string | number} gihwrValue 
 * @returns {number}
 */
function getTierScore(gihwrValue) {
    const tier = getTier(gihwrValue);
    return tierOrder[tier] || 0;
}

function parseColor(str) {
    if (!str) return {color:'C'};
    const cSet = new Set();
    if (str.match(/[W白]/)) cSet.add('W');
    if (str.match(/[U青]/)) cSet.add('U');
    if (str.match(/[B黒]/)) cSet.add('B');
    if (str.match(/[R赤]/)) cSet.add('R');
    if (str.match(/[G緑]/)) cSet.add('G');
    let code = 'C';
    if(cSet.size>1) code='M'; else if(cSet.size===1) code=Array.from(cSet)[0];
    else if(str.includes('Land')) code='L';
    return { color:code };
}

// --- Rendering ---
const canvas = document.getElementById('deck-canvas');
const ctx = canvas.getContext('2d');
const CARD_W = 200, CARD_H = 280, GAP = 10, COL_COUNT = 7;
const COLORS = { 'W':'#F8F8F6', 'U':'#C2D7E9', 'B':'#BAB1AB', 'R':'#E49977', 'G':'#9BD3AE', 'M':'#DCD6AC', 'C':'#D3D3D3', 'L':'#C7C2BC' };

document.getElementById('generate-btn').addEventListener('click', async () => {
    // 保存ボタンをリセット
    const saveBtn = document.getElementById('saveBtn');
    saveBtn.disabled = true;
    saveBtn.innerText = "画像を保存";


    const groupedCards = processDeck();
    if (Object.values(groupedCards).every(arr => arr.length === 0)) { 
        alert('デッキリストが空か、解析できませんでした。'); 
        return; 
    }

    // 【修正】グルーピングされた各カードの画像を読み込む
    for (const key in groupedCards) {
        const group = groupedCards[key];
        const loadedGroup = await Promise.all(group.map(async c => {
            const enKey = c.nameEn.toLowerCase().split(' // ')[0];
            const jpKey = c.nameJp.toLowerCase().split(' // ')[0];
            let file = localImageFiles[enKey] || localImageFiles[jpKey];
            let imgObj = null;
            if (file) {
                try {
                    imgObj = await loadImageFromFile(file);
                } catch (error) {
                    console.error(`画像の読み込みに失敗: ${c.displayName}`, error);
                }
            }
            return { ...c, imgObj };
        }));
        groupedCards[key] = loadedGroup;
    }

    // 描画関数を呼び出す
    renderDeck(groupedCards);
});

document.getElementById('saveBtn').addEventListener('click', () => {
    const canvas = document.getElementById('deck-canvas');
    const link = document.createElement('a');
    
    // ファイル名: decklist_日付_時間.png
    const now = new Date();
    const timeStr = now.toISOString().replace(/[-T:\.Z]/g, '').slice(0, 14);
    link.download = `decklist_${timeStr}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
});

function loadImageFromFile(file) {
    return new Promise(r => {
        const img = new Image();
        img.onload = () => r(img);
        img.onerror = () => r(null);
        img.src = URL.createObjectURL(file);
    });
}

/**
 * 【修正】グルーピング済みのカードデータを受け取り、Canvasに描画する関数
 * @param {object} groupedCards - processDeck()でマナコスト別に分類されたカードオブジェクト
 */
// 2. 描画メイン関数
function renderDeck(groupedCards) {
    console.log("描画開始。17landsデータ数:", gihwrData.length); // ★必ずログを出す
    const groupOrder = ['cost0', 'cost1', 'cost2', 'cost3', 'cost4', 'cost5', 'cost6plus', 'lands'];
    const groupSpacing = 20; // グループ間の追加の余白
    const countColWidth = 60; // 【追加】左側の枚数表示用スペース
    const headerHeight = 60; // 【修正】ヘッダー領域をテキスト1行分に縮小

    // --- 高さの事前計算 ---
    let requiredHeight = GAP;
    groupOrder.forEach(key => {
        const group = groupedCards[key] || [];
        if (group.length > 0) {
            const numRows = Math.ceil(group.length / COL_COUNT);
            requiredHeight += numRows * (CARD_H + GAP);
            requiredHeight += groupSpacing; // グループ下の余白
        }
    });

    // 【修正】キャンバスサイズを確定（枚数表示エリアの幅を追加）
    canvas.width = (CARD_W + GAP) * COL_COUNT + GAP + countColWidth;
    canvas.height = Math.max(requiredHeight, 400) + headerHeight + 40;

    // --- 本番描画 ---
    // 背景塗りつぶし
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 【修正】確保したヘッダー領域に統計情報とマナカーブを描画
    const deckStats = calculateDeckStats(groupedCards);
    if (deckStats.creatures + deckStats.spells + deckStats.lands > 0) {
        // 【修正】テキストをヘッダー中央に描画
        drawDeckStats(ctx, deckStats, GAP, GAP + 5);
    }

    // 【修正】カードの描画開始位置をヘッダー領域の下に設定
    let y = GAP + headerHeight;

    groupOrder.forEach(key => {
        const group = groupedCards[key] || [];

        if (group.length > 0) {
            const groupStartY = y; // このグループの開始Y座標を記録
            let totalCountInGroup = 0; // グループ内の合計枚数

            // グループ内のカードを描画（折り返しあり）
            for (let i = 0; i < group.length; i++) {
                const card = group[i];
                totalCountInGroup += card.count; // 枚数を加算

                const col = i % COL_COUNT;
                const row = Math.floor(i / COL_COUNT);
                // 【修正】枚数表示エリアの分だけ右にずらす
                const x = GAP + countColWidth + col * (CARD_W + GAP);
                const currentY = y + row * (CARD_H + GAP);

                if (card.imgObj) {
                    ctx.drawImage(card.imgObj, x, currentY, CARD_W, CARD_H);
                    drawBadge(ctx, x, currentY, card.count);
                    drawTierIcon(ctx, x, currentY, card.gihwr);
                } else {
                    drawFallbackCard(ctx, x, currentY, card);
                }
            }

            const numRowsInGroup = Math.ceil(group.length / COL_COUNT);
            const groupHeight = numRowsInGroup * (CARD_H + GAP) - GAP;

            // 【追加】グループの合計枚数を左側に描画
            ctx.save();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = "rgba(0, 0, 0, 0.8)";
            ctx.shadowBlur = 5;
            const centerY = groupStartY + groupHeight / 2;
            ctx.fillText(totalCountInGroup, GAP + (countColWidth / 2), centerY);
            ctx.restore();

            // Y座標を次のグループの開始位置に進める
            y += numRowsInGroup * (CARD_H + GAP) + groupSpacing;
        }
    });

    // --- クレジット表記の描画 ---
    // 【要件2 追記】
    ctx.save();
    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)'; // 薄いグレー/半透明の白
    ctx.font = '12px Arial';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'bottom';

    const creditText = "Data provided by 17Lands.com | © Wizards of the Coast | Generated by Decklist Generator";
    ctx.fillText(creditText, canvas.width - 20, canvas.height - 10);
    ctx.restore();

    // 【要件3】保存ボタンを有効化
    const saveBtn = document.getElementById('saveBtn');
    saveBtn.disabled = false;
    saveBtn.innerText = "画像を保存 (完了)";
}

/**
 * デッキの統計情報（カードタイプ別枚数、マナカーブ）を計算する
 * @param {object} groupedCards - マナコスト別にグループ化されたカードデータ
 * @returns {object} - 計算された統計情報
 */
function calculateDeckStats(groupedCards) {
    const stats = {
        creatures: 0,
        spells: 0,
        lands: 0,
        manaCurve: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, '6+': 0 },
    };

    // 全てのカードを一つの配列にフラット化
    const allCards = Object.values(groupedCards).flat();

    allCards.forEach(card => {
        if (card.type.includes('Land') || card.type.includes('土地')) {
            stats.lands += card.count;
        } else {
            if (card.type.includes('Creature') || card.type.includes('クリーチャー')) {
                stats.creatures += card.count;
            } else {
                stats.spells += card.count;
            }

            // マナカーブの計算
            if (card.cmc >= 6) {
                stats.manaCurve['6+'] += card.count;
            } else if (stats.manaCurve[card.cmc] !== undefined) {
                stats.manaCurve[card.cmc] += card.count;
            }
        }
    });

    return stats;
}

/**
 * デッキの統計情報（カードタイプ別枚数）をキャンバス左上に描画する
 * @param {CanvasRenderingContext2D} ctx - Canvasのコンテキスト
 * @param {object} stats - calculateDeckStatsで計算された統計情報
 * @param {number} x - 描画開始X座標
 * @param {number} y - 描画開始Y座標
 */
function drawDeckStats(ctx, stats, x, y) {
    ctx.save();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px Arial'; // 【修正】フォントサイズを拡大
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    const textY = y + 20; // Y座標を微調整

    // 視認性向上のため、テキストに黒い縁取り（影）を追加
    ctx.shadowColor = "rgba(0, 0, 0, 1)";
    ctx.shadowBlur = 4;

    // 【修正】横一列に描画
    ctx.fillText(`Creatures: ${stats.creatures}`, x + 20, textY);
    ctx.fillText(`Spells: ${stats.spells}`, x + 250, textY);
    ctx.fillText(`Lands: ${stats.lands}`, x + 450, textY);
    
    ctx.restore();
}

/**
 * 2. Tierアイコンを描画する
 * @param {CanvasRenderingContext2D} ctx - Canvasのコンテキスト
 * @param {number} x - カードの左上のX座標
 * @param {number} y - カードの左上のY座標
 * @param {string | number} gihwr - GIH WRのデータ
 */
function drawTierIcon(ctx, x, y, gihwr) {    
    const tier = getTier(gihwr);
    if (tier === 'U') return; // データなしの場合は描画しない

    // 座標と半径を定義
    const iconX = x + 30; 
    const iconY = y + 50; 
    const radius = 18;

    // Tierごとの色を定義
    const tierColors = {
        'A': '#d92626', // 赤
        'B': '#22a522', // 緑
        'C': '#d4a000', // 暗めの黄
        'D': '#2667d9', // 青
        'F': '#555555', // グレー
        'U': '#888888'
    };
    const mainRank = tier.charAt(0).toUpperCase();
    const color = tierColors[mainRank] || '#888888';

    ctx.save();

    // 1. 影の設定
    ctx.shadowColor = "rgba(0, 0, 0, 0.6)";
    ctx.shadowBlur = 5;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;

    // 2. 円（バッジ）の描画
    ctx.beginPath();
    ctx.arc(iconX, iconY, radius, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();

    // 3. 文字の描画
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = 'bold 20px Arial';
    ctx.fillText(tier, iconX, iconY + 1); // Y座標を微調整
}

function drawBadge(ctx, x, y, cnt) {
    // 【修正】バッジとフォントのサイズを大きくする
    const badgeW = 50;
    const badgeH = 30;
    ctx.fillStyle = 'rgba(0,0,0,0.8)'; 
    ctx.fillRect(x + 5, y + CARD_H - (badgeH + 5), badgeW, badgeH);
    ctx.fillStyle = '#fff'; ctx.textAlign='center'; ctx.font='bold 22px Arial';
    ctx.fillText('×'+cnt, x + 5 + (badgeW / 2), y + CARD_H - 10);
}
function drawFallbackCard(ctx, x, y, c) {
    const col = COLORS[c.color]||'#FFF';
    ctx.fillStyle='#000'; ctx.fillRect(x,y,CARD_W,CARD_H);
    ctx.fillStyle=col; ctx.fillRect(x+2,y+2,CARD_W-4,CARD_H-4);
    ctx.fillStyle='#444'; ctx.fillRect(x+10,y+35,CARD_W-20,120);
    ctx.fillStyle='#999'; ctx.textAlign='center'; ctx.font='10px Arial';
    ctx.fillText("No Image", x+CARD_W/2, y+100);
    
    ctx.fillStyle='#eee'; ctx.strokeRect(x+5,y+5,CARD_W-10,20); ctx.fillRect(x+5,y+5,CARD_W-10,20);
    ctx.fillStyle='#000'; ctx.textAlign='left'; ctx.font='bold 11px Arial';
    let dn = c.displayName.split('/')[0]; if(dn.length>18) dn=dn.substring(0,16)+'..';
    ctx.fillText(dn, x+8, y+19);
    
    if(c.cost) { ctx.textAlign='right'; ctx.font='10px Arial'; ctx.fillText(c.cost, x+CARD_W-8, y+19); }
    
    ctx.fillStyle='#eee'; ctx.fillRect(x+5,y+160,CARD_W-10,18);
    ctx.fillStyle='#000'; ctx.textAlign='left'; ctx.font='10px Arial';
    let td = c.type.split('---')[0]; if(td.length>25) td=td.substring(0,25)+'..';
    ctx.fillText(td, x+8, y+173);
    
    ctx.fillStyle='#dcdcdc'; ctx.fillRect(x+10,y+185,CARD_W-20,80);
    if(c.pt) {
        ctx.fillStyle='#fff'; ctx.strokeRect(x+CARD_W-45,y+CARD_H-25,40,20); ctx.fillRect(x+CARD_W-45,y+CARD_H-25,40,20);
        ctx.fillStyle='#000'; ctx.textAlign='center'; ctx.font='bold 12px Arial';
        ctx.fillText(c.pt, x+CARD_W-25, y+CARD_H-10);
    }
    drawBadge(ctx, x, y, c.count);
}

</script>
</body>
</html>